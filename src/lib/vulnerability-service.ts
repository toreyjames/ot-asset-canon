/**
 * OT Vulnerability Enrichment Service
 *
 * Integrates with:
 * - NVD (National Vulnerability Database)
 * - CISA KEV (Known Exploited Vulnerabilities)
 * - FIRST EPSS (Exploit Prediction Scoring System)
 */

import type { CanonAsset } from "@/types/canon";

// OT Vendor CPE mappings
const OT_VENDOR_CPE: Record<string, { vendor: string; products: Record<string, string> }> = {
  honeywell: {
    vendor: "honeywell",
    products: {
      experion: "experion",
      c300: "c300",
      "safety manager": "safety_manager",
      fim: "fim",
    },
  },
  rockwell: {
    vendor: "rockwellautomation",
    products: {
      controllogix: "controllogix",
      compactlogix: "compactlogix",
      "studio 5000": "studio_5000",
      factorytalk: "factorytalk",
    },
  },
  siemens: {
    vendor: "siemens",
    products: {
      "s7-1500": "simatic_s7-1500",
      "s7-1200": "simatic_s7-1200",
      "tia portal": "totally_integrated_automation_portal",
      wincc: "wincc",
    },
  },
  schneider: {
    vendor: "schneider-electric",
    products: {
      modicon: "modicon",
      triconex: "triconex",
    },
  },
  abb: {
    vendor: "abb",
    products: {
      "800xa": "800xa",
      ac500: "ac500",
    },
  },
  emerson: {
    vendor: "emerson",
    products: {
      deltav: "deltav",
      ovation: "ovation",
    },
  },
  yokogawa: {
    vendor: "yokogawa",
    products: {
      centum: "centum",
      prosafe: "prosafe",
    },
  },
  cisco: {
    vendor: "cisco",
    products: {
      "ie-4000": "industrial_ethernet",
      "ie-5000": "industrial_ethernet",
    },
  },
  fortinet: {
    vendor: "fortinet",
    products: {
      fortigate: "fortigate",
    },
  },
  "palo alto": {
    vendor: "paloaltonetworks",
    products: {
      "pa-": "pan-os",
    },
  },
  hirschmann: {
    vendor: "belden",
    products: {
      rsp: "hirschmann",
      rs20: "hirschmann",
    },
  },
};

export interface CVEResult {
  cveId: string;
  description: string;
  cvssV3Score: number | null;
  cvssV3Severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | null;
  attackVector: string | null;
  published: string;
  epssScore: number | null;
  epssPercentile: number | null;
  inKEV: boolean;
  cweIds: string[];
  references: string[];
}

export interface AssetVulnerabilityEnrichment {
  assetId: string;
  tagNumber: string;
  vendor: string;
  model: string;
  totalCVEs: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  kevCount: number;
  maxEPSS: number;
  riskTier: "critical" | "high" | "medium" | "low";
  topCVEs: CVEResult[];
  lastEnriched: string;
}

// Cache for API responses (simple in-memory cache)
const cache = new Map<string, { data: unknown; expiry: number }>();
const CACHE_TTL = 1000 * 60 * 60; // 1 hour

async function cachedFetch<T>(key: string, fetcher: () => Promise<T>): Promise<T> {
  const cached = cache.get(key);
  if (cached && cached.expiry > Date.now()) {
    return cached.data as T;
  }
  const data = await fetcher();
  cache.set(key, { data, expiry: Date.now() + CACHE_TTL });
  return data;
}

/**
 * Query NVD for CVEs matching a keyword
 */
async function queryNVD(keyword: string): Promise<CVEResult[]> {
  const cacheKey = `nvd:${keyword}`;

  return cachedFetch(cacheKey, async () => {
    const baseUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";

    // Don't filter by date - OT equipment has CVEs going back years
    const params = new URLSearchParams({
      keywordSearch: keyword,
      resultsPerPage: "100",
    });

    try {
      const response = await fetch(`${baseUrl}?${params}`, {
        headers: { "User-Agent": "OT-Asset-Canon/1.0" },
      });

      if (!response.ok) {
        console.error(`NVD API error: ${response.status}`);
        return [];
      }

      const data = await response.json();
      const vulnerabilities = data.vulnerabilities || [];

      return vulnerabilities.map((v: any) => parseCVE(v)).filter(Boolean);
    } catch (error) {
      console.error("NVD query failed:", error);
      return [];
    }
  });
}

/**
 * Parse NVD CVE response
 */
function parseCVE(vuln: any): CVEResult | null {
  try {
    const cve = vuln.cve;
    const cveId = cve.id;

    // Description
    const descriptions = cve.descriptions || [];
    const description = descriptions.find((d: any) => d.lang === "en")?.value || "";

    // CVSS v3
    const metrics = cve.metrics || {};
    const cvssV31 = metrics.cvssMetricV31?.[0]?.cvssData || {};
    const cvssV30 = metrics.cvssMetricV30?.[0]?.cvssData || {};
    const cvssData = cvssV31.baseScore ? cvssV31 : cvssV30;

    // CWE
    const weaknesses = cve.weaknesses || [];
    const cweIds: string[] = [];
    for (const w of weaknesses) {
      for (const desc of w.description || []) {
        if (desc.value?.startsWith("CWE-")) {
          cweIds.push(desc.value);
        }
      }
    }

    // References
    const refs = (cve.references || []).slice(0, 5).map((r: any) => r.url);

    return {
      cveId,
      description: description.slice(0, 500),
      cvssV3Score: cvssData.baseScore || null,
      cvssV3Severity: cvssData.baseSeverity || null,
      attackVector: cvssData.attackVector || null,
      published: cve.published?.slice(0, 10) || "",
      epssScore: null,
      epssPercentile: null,
      inKEV: false,
      cweIds,
      references: refs,
    };
  } catch {
    return null;
  }
}

/**
 * Get EPSS scores for CVEs
 */
async function getEPSSScores(cveIds: string[]): Promise<Map<string, { score: number; percentile: number }>> {
  if (cveIds.length === 0) return new Map();

  const cacheKey = `epss:${cveIds.sort().join(",")}`;

  return cachedFetch(cacheKey, async () => {
    const results = new Map<string, { score: number; percentile: number }>();

    try {
      const params = new URLSearchParams({ cve: cveIds.slice(0, 100).join(",") });
      const response = await fetch(`https://api.first.org/data/v1/epss?${params}`);

      if (!response.ok) return results;

      const data = await response.json();
      for (const item of data.data || []) {
        results.set(item.cve, {
          score: parseFloat(item.epss),
          percentile: parseFloat(item.percentile),
        });
      }
    } catch (error) {
      console.error("EPSS query failed:", error);
    }

    return results;
  });
}

/**
 * Get CISA KEV list
 */
async function getKEVList(): Promise<Set<string>> {
  const cacheKey = "kev:all";

  return cachedFetch(cacheKey, async () => {
    const kevSet = new Set<string>();

    try {
      const response = await fetch(
        "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
      );

      if (!response.ok) return kevSet;

      const data = await response.json();
      for (const vuln of data.vulnerabilities || []) {
        if (vuln.cveID) {
          kevSet.add(vuln.cveID);
        }
      }
    } catch (error) {
      console.error("KEV query failed:", error);
    }

    return kevSet;
  });
}

/**
 * Build search keyword for an asset
 */
function buildSearchKeyword(asset: Partial<CanonAsset>): string | null {
  const vendor = (
    asset.controlSystem?.controllerMake ||
    asset.network?.manufacturer ||
    ""
  ).toLowerCase();

  const model = (
    asset.controlSystem?.controllerModel ||
    asset.controlSystem?.model ||
    asset.network?.model ||
    ""
  ).toLowerCase();

  // Try to find vendor in our mapping
  for (const [vendorKey, vendorInfo] of Object.entries(OT_VENDOR_CPE)) {
    if (vendor.includes(vendorKey)) {
      // Check for specific product
      for (const [productKey, productCpe] of Object.entries(vendorInfo.products)) {
        if (model.includes(productKey)) {
          return `${vendorInfo.vendor} ${productCpe}`;
        }
      }
      // Just vendor
      return vendorInfo.vendor;
    }
  }

  // Fallback to raw vendor/model
  if (vendor || model) {
    return `${vendor} ${model}`.trim();
  }

  return null;
}

/**
 * Enrich a single asset with vulnerability data
 */
export async function enrichAssetVulnerabilities(
  asset: Partial<CanonAsset>
): Promise<AssetVulnerabilityEnrichment | null> {
  const keyword = buildSearchKeyword(asset);

  if (!keyword) {
    return null;
  }

  // Query NVD
  const cves = await queryNVD(keyword);

  if (cves.length === 0) {
    return {
      assetId: asset.id || "",
      tagNumber: asset.tagNumber || "",
      vendor: asset.controlSystem?.controllerMake || asset.network?.manufacturer || "Unknown",
      model: asset.controlSystem?.controllerModel || asset.network?.model || "",
      totalCVEs: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      kevCount: 0,
      maxEPSS: 0,
      riskTier: "low",
      topCVEs: [],
      lastEnriched: new Date().toISOString(),
    };
  }

  // Get EPSS scores
  const cveIds = cves.map((c) => c.cveId);
  const epssScores = await getEPSSScores(cveIds);

  // Get KEV list
  const kevList = await getKEVList();

  // Enrich CVEs with EPSS and KEV
  for (const cve of cves) {
    const epss = epssScores.get(cve.cveId);
    if (epss) {
      cve.epssScore = epss.score;
      cve.epssPercentile = epss.percentile;
    }
    cve.inKEV = kevList.has(cve.cveId);
  }

  // Sort by severity and EPSS
  cves.sort((a, b) => {
    // KEV first
    if (a.inKEV !== b.inKEV) return a.inKEV ? -1 : 1;
    // Then by CVSS
    const scoreA = a.cvssV3Score || 0;
    const scoreB = b.cvssV3Score || 0;
    if (scoreA !== scoreB) return scoreB - scoreA;
    // Then by EPSS
    return (b.epssScore || 0) - (a.epssScore || 0);
  });

  // Count by severity
  const criticalCount = cves.filter((c) => c.cvssV3Severity === "CRITICAL").length;
  const highCount = cves.filter((c) => c.cvssV3Severity === "HIGH").length;
  const mediumCount = cves.filter((c) => c.cvssV3Severity === "MEDIUM").length;
  const lowCount = cves.filter((c) => c.cvssV3Severity === "LOW").length;
  const kevCount = cves.filter((c) => c.inKEV).length;
  const maxEPSS = Math.max(...cves.map((c) => c.epssScore || 0));

  // Determine risk tier
  let riskTier: "critical" | "high" | "medium" | "low";
  if (kevCount > 0 || criticalCount >= 3 || maxEPSS > 0.5) {
    riskTier = "critical";
  } else if (criticalCount >= 1 || highCount >= 5 || maxEPSS > 0.1) {
    riskTier = "high";
  } else if (highCount >= 2 || mediumCount >= 5) {
    riskTier = "medium";
  } else {
    riskTier = "low";
  }

  return {
    assetId: asset.id || "",
    tagNumber: asset.tagNumber || "",
    vendor: asset.controlSystem?.controllerMake || asset.network?.manufacturer || "Unknown",
    model: asset.controlSystem?.controllerModel || asset.network?.model || "",
    totalCVEs: cves.length,
    criticalCount,
    highCount,
    mediumCount,
    lowCount,
    kevCount,
    maxEPSS,
    riskTier,
    topCVEs: cves.slice(0, 10),
    lastEnriched: new Date().toISOString(),
  };
}

/**
 * Enrich multiple assets (with rate limiting)
 */
export async function enrichMultipleAssets(
  assets: Partial<CanonAsset>[],
  onProgress?: (completed: number, total: number) => void
): Promise<Map<string, AssetVulnerabilityEnrichment>> {
  const results = new Map<string, AssetVulnerabilityEnrichment>();

  // Filter to assets that have vendor/model info
  const enrichable = assets.filter((a) => buildSearchKeyword(a) !== null);

  // Dedupe by vendor/model to reduce API calls
  const uniqueKeywords = new Map<string, Partial<CanonAsset>[]>();
  for (const asset of enrichable) {
    const keyword = buildSearchKeyword(asset)!;
    if (!uniqueKeywords.has(keyword)) {
      uniqueKeywords.set(keyword, []);
    }
    uniqueKeywords.get(keyword)!.push(asset);
  }

  let completed = 0;
  const total = uniqueKeywords.size;

  for (const [keyword, assetGroup] of uniqueKeywords) {
    // Rate limit: NVD allows 5 requests per 30 seconds without API key
    await new Promise((resolve) => setTimeout(resolve, 6500));

    // Enrich first asset in group
    const enrichment = await enrichAssetVulnerabilities(assetGroup[0]);

    if (enrichment) {
      // Apply to all assets with same vendor/model
      for (const asset of assetGroup) {
        results.set(asset.id!, {
          ...enrichment,
          assetId: asset.id!,
          tagNumber: asset.tagNumber || "",
        });
      }
    }

    completed++;
    onProgress?.(completed, total);
  }

  return results;
}

/**
 * Get vulnerability summary for display
 */
export interface VulnerabilitySummary {
  totalAssets: number;
  enrichedAssets: number;
  totalCVEs: number;
  criticalCVEs: number;
  highCVEs: number;
  kevCVEs: number;
  criticalAssets: number;
  highAssets: number;
  topVulnerableAssets: {
    tagNumber: string;
    vendor: string;
    totalCVEs: number;
    criticalCount: number;
    kevCount: number;
    riskTier: string;
  }[];
}

export function summarizeVulnerabilities(
  enrichments: Map<string, AssetVulnerabilityEnrichment>
): VulnerabilitySummary {
  const values = Array.from(enrichments.values());

  const totalCVEs = values.reduce((sum, e) => sum + e.totalCVEs, 0);
  const criticalCVEs = values.reduce((sum, e) => sum + e.criticalCount, 0);
  const highCVEs = values.reduce((sum, e) => sum + e.highCount, 0);
  const kevCVEs = values.reduce((sum, e) => sum + e.kevCount, 0);

  const criticalAssets = values.filter((e) => e.riskTier === "critical").length;
  const highAssets = values.filter((e) => e.riskTier === "high").length;

  // Sort by risk
  const sorted = [...values].sort((a, b) => {
    const tierOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    const tierDiff = tierOrder[a.riskTier] - tierOrder[b.riskTier];
    if (tierDiff !== 0) return tierDiff;
    return b.totalCVEs - a.totalCVEs;
  });

  return {
    totalAssets: values.length,
    enrichedAssets: values.filter((e) => e.totalCVEs > 0).length,
    totalCVEs,
    criticalCVEs,
    highCVEs,
    kevCVEs,
    criticalAssets,
    highAssets,
    topVulnerableAssets: sorted.slice(0, 10).map((e) => ({
      tagNumber: e.tagNumber,
      vendor: e.vendor,
      totalCVEs: e.totalCVEs,
      criticalCount: e.criticalCount,
      kevCount: e.kevCount,
      riskTier: e.riskTier,
    })),
  };
}
